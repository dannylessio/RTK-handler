\documentclass[a4paper,11pt, oneside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{dirtree}
\usepackage{float}
\usepackage{listings}

\lstset{basicstyle=\ttfamily}

\title{ RTK-handler Documentation\\v0.1 }
\author{Danny Lessio - danny.lessio@gmail.com}
\date{\today}
\begin{document}

  \maketitle
  \tableofcontents

  \newpage
  \part{ What this software does }
    \section{ Short description }
    Given a .csv file containing the informations about the projections (projections angles, proj\_offset\_x/y, \texttt{Io} source intensity) and an .mha projection stack, RTK-handler helps with the creation of the RTK .xml geometry, with the normalization of the .mha stack and with the reconstruction using the rtkfdk procedure.
    
    \section{ Detailed description }
    During the acquisition phase, the detector (for each projection) has absorbed the \texttt{I} intensity wich
    follows the Lambert-Beer law:    
    \begin{equation}
    \texttt{I} = \texttt{Io} \cdot e^{- (\mu1, \mu2, ... ,\mu n) }
    \end{equation}
    Where:
    \begin{itemize}
      \item \texttt{I} = Attenuated intesity.
      \item \texttt{Io} = Source intensity.
      \item \texttt{$ e $} = Euler number.
      \item \texttt{$ (\mu1, \mu2, ... ,\mu n) $} = Attenuation value.
    \end{itemize}
    With simple algebric operation we can get the attenuation value if we have the \texttt{Io} source intensity:
    \begin{equation}
    (\mu1, \mu2, ... ,\mu n) = - \log_e{I/Io}
    \end{equation}
    This process is also known as Normalization and the \texttt{Io} source intensity can be:
    \begin{enumerate}
      \item Manually saved for each projection:
      \par This must be done for each projection during the forward projection phase ( for example in a .csv file ). This is the best choice because each projection will not have an approximated intensity values and also it is always possible.
      
      \item Automatically approximated:
      \par If the object size is smaller than the detector, some pixels of it will receive x-rays with no attenuation. The source intensity can be calculated by choosing a projection's pixel with the highest intensity value or with other techniques like taking the average of all the non attenuated pixels. This is not always possible.
    \end{enumerate}
 
  The RTK library reads the stack of projections with a class called ProjectionsReader and from its documentation:
  \par \textit{"The universal projections reader of RTK (raw data converted to attenuation). Currently handles .his (Elekta Synergy), .hnd (Varian OBI), .tiff (Digisens), .edf (ESRF), .XRad. For all other ITK file formats, it is assumed that the attenuation is directly passed and there is no processing."\newline}
  \par So, RTK makes an automatic Normalization only for a specific set of projections types. Before reading the .mha stack with the ProjectionsReader class it must be normalized manually obtaining the \texttt{Io} intensity directly from a .csv file.\newline
  \par RTK-handler automates the Normalization process according to (2) and creates the .xml geometry according to this:\newline
  \url{http://www.openrtk.org/Doxygen/geometry.pdf}\newline\newline
  It also provides an interface to the rtkfdk procedure in order to get a reconstruction from:
  \begin{itemize}
    \item Normalized stack:
    Simply reconstructs with rtkfdk.
    \newline
    \\OR
    \item Non normalized .tiff set:
    It performs an auto-normalization and than reconstructs with rtkfdk.\newline
    \end{itemize}
    The binary rtkfdk is simply executed by Python from the \textit{/path\_of\_RTK-bin/RTK-bin/bin} 
    folder by choosing the .mha projections stack and the .xml geometry file directly by the folder structure generated by RTK-handler and asking the rest of the parameters directly from the user. 
  
  
  
  \part{ Input Requirements }
    
    \section{ .csv file }
    \subsection{ structure }
    The .csv file is required by the RTK-handler application. It must have the following structure:
    
    \begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|l|}
    \hline
    Projection Name & Angle & Projection offset x & Projection offset y & \texttt{Io} intensity \\ \hline
    \end{tabular}
    \end{table}
    
    The rows must not contain any title, ex: the position (0,1) must contain the first projection angle.
    \begin{itemize}
    \item Projection Name:
      \par All this column can be blank, RTK-handler fills it with an incremental name during the creation of the .xml geometry.
    \item Angle:
      \par The angle of each projection.
    \item Projection offset x/y:
      \par The offset from the detector origin (wich is assumed to be in the center) to the image origin (if not specified an .mha slice have the origin situated on the top left corner).
    \item Io intensity:
    \par The \texttt{Io} source intensity readed during the acquisition of each projection.
    \end{itemize}
    
    \section{ .mha projection stack }
    \subsection{ Structure }
    The .mha metaimage format is useful to handle n dimensional images. The
    internal structure is like:
    \newline
    \newline
    < HEADER >
    \newline
    < RAWDATA >
    \newline
    \newline 
    The < HEADER > part contains metaobject that indicate how to read the < RAWDATA > part, and adds informations about dimensions.
    \subsection{ Header }
    This Metaobjects are essential:
    \begin{itemize}
    \item NDims
    \par The number of dimensions, if there's more than one projection (surely there's more than one), this value will be 3.
    \item DimSize
    \par The dimension of the image in pixel. 
    \newline 
    For example if "NDims = 1024, 512, 60" we have 60 pojections each with 1024x512 pixels (this is also the detector size in pixel). 
    \item ElementByteOrderMSB
    \par If is set to "True", the raw data is MSB otherwise is LSB.
    \item ElementSize
    \par Single pixel size of the detector on u and v directions (in millimeters). Example: "ElementSize = 0.096, 0.096, 0.0"
    \item ElementType
    \par The type of data that each pixel holds. 
    
    \item ElementDataFile
    \par For an .mha image this is set to "Local" and indicates that the raw data begins at the beginning of the next line.
    \end{itemize}
    For more informations about .mha Metaobjects visit:\newline
    \url{http://www.itk.org/Wiki/ITK/MetaIO/Documentation}
    
    \section{ Additional informations }
    Those information must be known before the RTK-handler usage.
    \subsection{ About acquisition infrastructure }
    \begin{itemize}
      \item Source to Isocenter Distance
      \item Source to Detector Distance
    \end{itemize}
    \subsection{ About detector }
    \begin{itemize}
      \item Single pixel size on direction u (in millimeters)
      \item Single pixel size on direction v (in millimeters)
    \end{itemize}
    
    \subsection{ About reconstructed object }
    \begin{itemize}
      \item Voxel size on x, y, z directions (in millimeters)
      \item Reconstructed object size on x, y, z directions
    \end{itemize}
    
  \part{ Dependencies }
    \section{ Python 3 and Lua 5.1 }
    \subsection{ Assert Python >= 3 }
    Python 3 or greather must be the default Python interpreter on the system. To check this simply type:
    \begin{lstlisting}
      python --version
    \end{lstlisting}
    \subsection{ Assert Lua 5.1 }
    An installation of Lua 5.1 ( exactly this version ) must be installed in the system, but is not necessary that this is the default one. To check the default installation type:
    \begin{lstlisting}
      lua -v
    \end{lstlisting}
    \section{ ITK and RTK }
    \subsection{  Auto compilation for Linux machines}
    
      \par This script fully automates the compilation process of RTK for a Linux machine. Maybe it can also work on Mac OS but it hasn't been tested yet:
    \newline
    \url{https://github.com/dannylessio/auto-build-RTK}
    
    \subsection{ Default compilation }
     Follow the 0-1-2-3 installation steps that can be found here:
    \newline
    \url{http://wiki.openrtk.org/index.php/Main_Page#Step_0_-_Getting_ITK}
    
    \section{ SimpleRTK }
    \subsection{ Compilation }
    Open the terminal inside the RTK-bin folder, than run:
    \begin{lstlisting}
      ccmake ../RTK
    \end{lstlisting}
    Turn ON both BUILD\_SIMPLERTK and WRAP\_PYTHON options, if one of those option is not visible press [t] to have a full view of all available options. After that press [c] to configure until the phrase "Press [g] to generate and exit" appears at the bottom of the terminal. When this shows up press [g].
    Without changing directory execute:
    \begin{lstlisting}
      make -j <NUMBER OF CORES>
    \end{lstlisting}
    If the compilation process is terminated with no errors, install the .egg package inside the Python3 environment:
    \begin{lstlisting}
      cd SimpleRTK-build/Wrapping/PythonPackage
      sudo python setup.py install
    \end{lstlisting}
    
    \subsection{Troubleshooting}
    If the compilation with make is terminated with a "pkg\_resources" error, replace default ez\_setup.py inside:
    \newline
    RTK-bin/SimpleRTK-build/Wrapping/PythonPackage/ez\_setup.py
    \newline\newline
    With this:
    \newline
    \url{https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez\_setup.py}
    \newline\newline
    Than remake RTK.
    
    
    
    \section{ SimpleITK }
    \subsection{ Installation from precompiled source }
    Before start with an heavy compilation process it is possible that there's a matching distribution available on PyPi (for Windows this may work) :
    \begin{lstlisting}
      pip install SimpleITK
    \end{lstlisting}
    If there are some problems, proceed with the compilation from source.
    \subsection{ Compilation }
    This compilation requires high (more than 4Gb) amount of memory, so make sure to have a swap partition enabled. 
    \par First, clone the lastest source available from github:
    \begin{lstlisting}
      git clone https://github.com/SimpleITK/SimpleITK
    \end{lstlisting}
    Without entering it, make a folder called \texttt{SimpleITK-bin}\newline
    \begin{lstlisting}
      mkdir SimpleITK-bin
    \end{lstlisting}
    Enter inside SimpleITK-bin and run ccmake:
    \begin{lstlisting}
      cd SimpleITK-bin
      ccmake ../SimpleITK
    \end{lstlisting}
    Now, press [t] to have a full view of all the available options and fill the relevant options like in this example:
    \begin{lstlisting}
       CMAKE_BUILD_TYPE         Release
       ITK_DIR                  /UniFE/ITK-bin
       SITK_LUA_EXECUTABLE      /usr/bin/lua5.1
       SWIG_EXECUTABLE          /usr/bin/swig
       WRAP_PYTHON              ON
    \end{lstlisting}
    
    After that, press [c] to configure and if there are no errors, press [g] to generate and exit.
    Now execute (this requires a long time):
    \begin{lstlisting}
      make -j <NUMBER OF CORES>
    \end{lstlisting}
    If the compilation process is terminated with no errors, install the .egg package inside the Python3 environment:
    \begin{lstlisting}
      cd Wrapping/Python/Packaging
      sudo python setup.py install
    \end{lstlisting}
    
    
    
  
  If the path is correct, RTK-handler exits with a "configuration success" message and the configuration is done.
  
  \part{ RTK-handler }
    All the following section must be executed in order.
    
    \section{ Installation and configuration }
    \subsection{ Installation }
    Simply install it by using the pip package manager:
    \begin{lstlisting}[]
    pip install RTK-handler
    \end{lstlisting}
    \subsection{ Configuration }
    As a user without root privilege open the terminal and execute:
   \begin{lstlisting}[]
    RTK-handler -p
    \end{lstlisting}
    
    Now RTK-handler asks to insert the full RTK-bin path like this:
    \begin{lstlisting}[]
    /UniFE/RTK-bin
    \end{lstlisting}
    
    \section{ Create the folder structure }
    Create a folder that holds all your projections file:
    \begin{enumerate}
      \item The non-normalized .mha stack
      \item The csv file    
    \end{enumerate}
    
    \par First open the terminal and enter to this folder, than execute:
    \begin{lstlisting}
    RTK-handler -s  
    \end{lstlisting}
    
    
  \par This will create the required folders structure and leaves you with this structure:\newline
    
    \dirtree{%
    .1 csv.
    .1 geometry.
    .1 projections.
    .2 non\_normalized.
    .3 mha.
    .3 set\_of\_tiff.
    .2 normalized.
    .3 mha.
    .3 set\_of\_tiff.
    .1 reconstructions.
    .2 from.
    .3 mha\_normalized\_proj.
    .3 tiff\_without\_norm\_proj.
    .1 your\_file.csv.
    .1 your\_stack.mha\newline.
    }
    
    
    After that move your\_file.csv inside the csv folder and your\_stack.mha inside projections/non\_normalized/mha folder.
    \section{ Generate the .xml geometry }
    From the top folder execute:
    \begin{lstlisting}
    RTK-handler -g  
    \end{lstlisting}
    And follow the instructions, the program will ask for:
    \begin{itemize}
      \item Single pixel detector size on u direction
      \item Single pixel detector size on v direction
      \item The Source to Isocenter distance
      \item The Source to Detector distance
    \end{itemize}
    Than it search for the .csv file inside the csv folder and creates the geometry.xml file inside the geometry folder. The first column of the .csv file is updated with an incremental name.
    \section{ Normalize the .mha stack }
    From the top folder execute:
    \begin{lstlisting}
      RTK-handler -n
    \end{lstlisting}
    RTK-handler first separate the .mha stack into a set of .tiff images and put them inside projections/non\_normalized/set\_of\_tiff folder. For each saved image it reads the corresponding \texttt{Io} value inside the .csv column, it makes the normalization according to (2) and stores the normalized set inside projections/normalized/set\_of\_tiff folder. At the end it gather this last set inside a single normalized .mha stack.  
    \section{ Rtkfdk reconstruction }
    From the top folder execute:
    \begin{lstlisting}
      RTK-handler -r
    \end{lstlisting}
    
    This begin an rtkfdk recostruction, the procedure asks for 2 options:
    \begin{enumerate}
      \item Reconstruct from normalized .mha
      \par It stores the result inside:
      \newline
      reconstructions/from/mha\_normalized\_proj/
      \item Reconstruct from non normalized tiff set
      \par It stores the result inside:
      \newline
      reconstructions/from/tiff\_without\_norm\_proj/
    \end{enumerate}
    After that the procedure will ask those informations:
      \begin{itemize}
        \item Spacing on x,y,z directions (voxel size on x,y,z)
        \item Dimension of the reconstructed object on x,y,z directions
      \end{itemize}
      
      Now the RTK-handler execute the RTK-bin/bin/rtkfdk and stores the .mha reconstructed stack inside the folders previously described.
    \section{ Clean the folder structure }
    This command is useful in order to clean some disk space, it removes all the content inside:
    \begin{lstlisting}
      projections/non_normalized/set_of_tiff
      projections/normalized
    \end{lstlisting}
    But leaves all the relevant file: .csv file, geometry.xml, .mha non normalized projections and the reconstructed stack.
    It also deletes the previously created folder structure with "RTK-handler -s".
    
  
\end{document}
